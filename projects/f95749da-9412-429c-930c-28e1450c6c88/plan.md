# 实现计划

## 用户需求
写一个计时器软件


## 详细计划
# 计时器软件技术实现计划

## 一、系统架构设计

### 1.1 整体架构模式

本项目采用分层架构模式，将系统划分为表现层、业务逻辑层、数据访问层和基础设施层四个主要层次。这种架构选择基于以下考量：计时软件需要清晰的职责分离以确保核心计时逻辑的稳定性和可靠性；分层架构便于团队并行开发不同模块；同时为后续功能扩展和平台移植提供良好的基础结构。表现层负责用户界面的渲染和交互处理，业务逻辑层承载计时计算、状态管理和任务调度等核心功能，数据访问层处理所有与持久化存储相关的操作，基础设施层则封装与操作系统交互的底层接口。

架构设计遵循关注点分离原则，各层之间通过明确定义的接口进行通信，避免直接依赖具体实现。表现层不直接访问数据存储，而是通过业务逻辑层提供的服务接口获取数据；数据访问层不包含任何业务逻辑，仅负责数据的序列化和反序列化。这种设计使得各层可以独立演进，例如更换用户界面框架或存储后端时，不会影响其他层的实现。

### 1.2 设计模式应用

项目在核心模块中应用多种经过验证的设计模式，以确保代码的可维护性和可扩展性。状态模式用于管理计时器的运行状态转换，每个状态（运行中、已暂停、已停止）封装为独立的状态对象，内部处理该状态下的合法操作和状态转换逻辑。这种方式消除了大量的条件判断语句，使状态相关的代码更加清晰，也便于后续添加新的状态类型。

观察者模式用于实现计时变化的事件通知机制，当计时器的累计时间发生变化时，系统通过事件总线向所有注册的观察者发送通知，用户界面组件、记录模块和通知服务都可以订阅这些事件并执行相应的处理。这种松耦合的设计使得添加新的事件消费者不需要修改计时器核心代码。

单例模式应用于全局服务管理，确保计时引擎、事件总线和配置管理等全局唯一的服务在应用生命周期内只有一个实例。对于多计时器场景，则采用工厂模式管理计时器对象的创建和销毁，每个计时器实例拥有独立的状态空间，通过工厂统一管理生命周期。

策略模式用于处理不同计时模式的算法差异，正向计时和倒计时虽然都是时间计算，但逻辑细节有所不同。通过策略模式将两种计时算法的实现封装在独立的对象中，可以在运行时动态切换，也便于未来添加新的计时模式。

### 1.3 模块划分与职责

系统划分为六个核心功能模块和三个支撑模块。核心功能模块包括计时引擎模块、计时器管理模块、任务管理模块、历史记录模块、用户界面模块和通知服务模块。支撑模块包括配置管理模块、数据持久化模块和插件扩展模块。

计时引擎模块是系统的核心，负责时间计算的高精度实现，采用"记录起点、计算差值"算法确保计时准确性。该模块提供计时操作的基本接口，包括启动、暂停、恢复、停止等，并维护计时器状态的内部表示。计时引擎需要直接与操作系统时间接口交互，获取高精度时间戳，并处理系统时间变更等边界情况。

计时器管理模块负责多个计时器实例的生命周期管理，包括创建新计时器、查找活跃计时器、切换当前焦点计时器、删除不需要的计时器等。该模块维护全局计时器注册表，提供按名称、ID、任务等条件的查询功能，并协调多个计时器之间的资源竞争。

任务管理模块处理与计时器关联的任务信息，支持任务的创建、编辑、删除和状态变更。任务与计时器之间是一对多的关系，一个任务可以关联多个计时器记录，便于用户分析时间分配。该模块提供任务分类、优先级管理和完成状态跟踪等功能。

历史记录模块负责计时会话数据的持久化存储和查询管理。每次完整的计时会话（启动到停止）生成一条记录，包含时间戳、时长、关联任务和备注等字段。该模块实现高效的时间范围查询和条件筛选，支持数据导出和统计分析。

用户界面模块采用响应式设计，根据不同操作系统提供原生体验。界面分为计时显示区、操作控制区、历史记录区和任务管理区四个主要区域，支持键盘快捷键和触屏手势操作。界面组件通过观察者模式订阅计时引擎的事件，实时更新显示内容。

通知服务模块处理计时器相关的提醒和通知，支持视觉提示、声音提醒和系统通知三种方式。该模块封装了各操作系统的通知接口，提供统一的提醒配置管理，包括提醒延迟策略和重复提醒设置。

## 二、核心组件详细设计

### 2.1 计时引擎组件

计时引擎组件是整个系统的技术核心，其设计质量直接决定计时精度和可靠性。组件内部采用高精度时间源接口，在Windows平台使用QueryPerformanceCounter，在macOS使用mach_absolute_time，在Linux使用clock_gettime。这些接口提供纳秒级的时间分辨率，足以满足毫秒级精度的需求。

组件的核心数据结构是TimerState类，包含以下关键字段：累计时间（elapsed_ms，int64类型）、运行状态（status，枚举值：IDLE、RUNNING、PAUSED、STOPPED）、开始时间戳（start_timestamp，int64类型毫秒时间戳）、暂停时刻记录（pause_timestamp，用于恢复时计算暂停时长）、累计暂停时长（total_paused_ms）、计时模式（mode：FORWARD/COUNTDOWN）、倒计时目标时长（target_ms，仅倒计时模式使用）。

计时计算采用相对时间差算法而非绝对时间累加。启动时记录start_timestamp为当前系统时间戳，此后每次需要获取累计时间时，计算当前时间戳与start_timestamp的差值，减去total_paused_ms。这种方法的优势在于：系统休眠期间时间不会计入（因为恢复时差值自然跳过了休眠期）、系统时间调整不会影响计时结果、长时间运行误差极小。

组件提供TimerEngine类作为全局入口点，采用单例模式确保全局唯一。该类维护活跃计时器列表和事件广播器，主要方法包括：create_timer(mode, duration_ms, name)创建新计时器并返回引用、get_timer(timer_id)获取指定计时器实例、get_active_timers()返回所有非停止状态的计时器列表、tick()由主循环调用的更新函数，处理状态检查和提醒触发。

### 2.2 数据持久化组件

数据持久化组件负责所有用户数据的读写操作，采用分层设计将存储格式与业务逻辑分离。组件支持两种存储后端：SQLite数据库用于结构化数据存储，JSON文件用于配置和轻量级数据导出。这种混合策略兼顾了查询效率和可移植性。

数据库设计采用三表结构：timers表存储计时器模板和配置信息、sessions表存储历史计时记录、tasks表存储任务定义。表之间通过外键关联：sessions.timer_id关联timers表、sessions.task_id关联tasks表。数据库模式设计考虑了查询性能，对常用查询字段创建索引，如sessions表的start_time索引和task_id索引。

数据访问采用Repository模式，每类数据对应一个Repository类。TimerRepository提供计时器的CRUD操作和按条件查询、SessionRepository提供历史记录的增删改查和统计分析方法、TaskRepository提供任务管理功能。Repository类封装SQL细节，向上层提供面向对象的数据接口。

组件实现数据自动备份机制，每次写操作前先创建增量备份文件，保留最近10次备份。应用启动时检查数据完整性，如发现损坏可从备份恢复。数据导出功能支持JSON和CSV格式，用户可以将历史记录导出到其他应用进行分析。

### 2.3 用户界面组件

用户界面组件采用模型-视图-视图模型（MVVM）模式，将界面逻辑与业务逻辑分离。模型层直接对应业务数据对象，视图层负责渲染和用户交互，视图模型层作为中间层处理数据转换和命令绑定。这种模式使得界面代码可以独立于业务逻辑进行测试，也便于在不同平台间复用视图模型。

界面框架选择跨平台方案，Windows平台使用PyQt6或PySide6，macOS和Linux同样适用。PyQt提供原生的外观风格和良好的性能，能够满足资源占用限制要求。界面采用响应式布局，支持窗口大小调整和DPI自适应，确保在不同分辨率下清晰可读。

主窗口布局分为左侧计时器卡片区、中间计时显示区、右侧历史记录区和底部状态栏。计时器卡片采用ListView组件渲染，支持虚拟滚动以处理大量计时器。每个卡片显示名称、当前时间、运行状态和关联任务，用户
