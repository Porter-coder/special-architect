"""
API Routes for AI Code Flow

FastAPI routes for code generation, progress streaming, and file retrieval.
"""

import asyncio
import logging
from typing import Dict, List
from uuid import UUID

from fastapi import APIRouter, HTTPException, BackgroundTasks
from fastapi.responses import StreamingResponse
from sse_starlette.sse import EventSourceResponse

from ..models.code_request import CodeGenerationRequest, RequestStatus
from ..models.process_phase import ProcessPhase, PhaseName, get_phase_message, is_valid_phase_transition
from ..models.generated_project import GeneratedProject
from ..services.ai_service import AIServiceError
from ..services.file_service import FileServiceError
from ..services.container import get_ai_service, get_file_service


router = APIRouter()
logger = logging.getLogger(__name__)

# In-memory storage for active requests (in production, use Redis/database)
active_requests: Dict[UUID, CodeGenerationRequest] = {}
request_phases: Dict[UUID, List[ProcessPhase]] = {}


@router.post("/generate", response_model=Dict)
async def start_code_generation(request: CodeGenerationRequest, background_tasks: BackgroundTasks) -> Dict:
    """
    Start a code generation request.

    Accepts a natural language request and initiates the AI-powered code generation process.
    Returns immediately with a request ID for progress tracking.
    """
    try:
        # Store request
        active_requests[request.request_id] = request
        request_phases[request.request_id] = []

        # Start background processing
        background_tasks.add_task(process_code_generation, request.request_id, request.user_input)

        logger.info(f"代码生成请求已启动: {request.request_id}")

        return {
            "request_id": str(request.request_id),
            "message": "代码生成请求已开始处理",
            "status": "processing"
        }

    except Exception as e:
        logger.error(f"启动代码生成失败: {e}")
        raise HTTPException(status_code=500, detail="启动代码生成失败，请稍后重试")


@router.get("/generate/{request_id}/stream")
async def stream_generation_progress(request_id: UUID):
    """
    Stream real-time progress updates for a code generation request.

    Uses Server-Sent Events to provide live updates of the generation process,
    including phase changes and educational messages.
    """
    if request_id not in active_requests:
        raise HTTPException(status_code=404, detail="请求不存在")

    async def event_generator():
        """Generate SSE events for the request progress."""
        last_phase_count = 0

        while True:
            try:
                # Check if request is still active
                if request_id not in active_requests:
                    yield {"event": "error", "data": "请求已完成或不存在"}
                    break

                request = active_requests[request_id]
                phases = request_phases.get(request_id, [])

                # Send new phases since last check
                for i in range(last_phase_count, len(phases)):
                    phase = phases[i]
                    yield {
                        "event": "phase",
                        "data": {
                            "phase": phase.phase_name.value,
                            "message": phase.educational_message,
                            "timestamp": phase.timestamp.isoformat()
                        }
                    }

                    # Send thinking trace if available
                    if phase.thinking_trace:
                        yield {
                            "event": "thinking",
                            "data": phase.thinking_trace
                        }

                last_phase_count = len(phases)

                # Check if generation is complete
                if request.status in [RequestStatus.COMPLETED, RequestStatus.FAILED]:
                    if request.status == RequestStatus.COMPLETED:
                        # Load project info
                        project = get_file_service().load_project_metadata(request_id)
                        if project:
                            yield {
                                "event": "complete",
                                "data": {
                                    "project_id": str(project.project_id),
                                    "main_file": project.main_file_path,
                                    "project_name": project.project_name
                                }
                            }
                        else:
                            yield {"event": "error", "data": "项目生成失败"}
                    else:
                        yield {
                            "event": "error",
                            "data": request.error_message or "代码生成失败"
                        }
                    break

                # Wait before next check
                await asyncio.sleep(1)

            except Exception as e:
                logger.error(f"SSE 流错误: {e}")
                yield {"event": "error", "data": "流式响应错误"}
                break

    return EventSourceResponse(event_generator())


@router.get("/generate/{request_id}/files")
async def get_generated_files(request_id: UUID) -> Dict:
    """
    Retrieve all files generated for a completed request.

    Returns the project structure and file contents for download.
    """
    try:
        # Check if request exists and is completed
        if request_id not in active_requests:
            raise HTTPException(status_code=404, detail="请求不存在")

        request = active_requests[request_id]
        if request.status == RequestStatus.PROCESSING:
            raise HTTPException(status_code=425, detail="请求正在处理中，请稍后查看")

        if request.status != RequestStatus.COMPLETED:
            raise HTTPException(status_code=404, detail="请求尚未完成或生成失败")

        # Load project metadata
        project = get_file_service().load_project_metadata(request_id)
        if not project:
            raise HTTPException(status_code=404, detail="项目文件不存在")

        # Load all files
        files = get_file_service().read_generated_files(request_id)

        return {
            "project_name": project.project_name,
            "main_file": project.main_file_path,
            "files": [
                {
                    "path": path,
                    "content": content,
                    "encoding": "utf-8"  # Constitution requirement
                }
                for path, content in files.items()
            ]
        }

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"获取生成文件失败: {e}")
        raise HTTPException(status_code=500, detail="获取文件失败，请稍后重试")


@router.post("/generate/{request_id}/retry")
async def retry_generation(request_id: UUID, background_tasks: BackgroundTasks) -> Dict:
    """
    Retry a failed code generation request.

    Creates a new request cycle for the same user input.
    """
    try:
        # Check if original request exists and failed
        if request_id not in active_requests:
            raise HTTPException(status_code=404, detail="原请求不存在")

        original_request = active_requests[request_id]
        if original_request.status != RequestStatus.FAILED:
            raise HTTPException(status_code=400, detail="只有失败的请求才能重试")

        # Create new request with same input
        from uuid import uuid4
        new_request_id = uuid4()
        new_request = CodeGenerationRequest(
            request_id=new_request_id,
            user_input=original_request.user_input
        )

        # Store new request
        active_requests[new_request_id] = new_request
        request_phases[new_request_id] = []

        # Start background processing
        background_tasks.add_task(process_code_generation, new_request_id, new_request.user_input)

        logger.info(f"重试请求已启动: {new_request_id} (原请求: {request_id})")

        return {
            "request_id": str(new_request_id),
            "message": "重试请求已开始处理",
            "status": "processing"
        }

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"重试请求失败: {e}")
        raise HTTPException(status_code=500, detail="重试请求失败，请稍后重试")


async def process_code_generation(request_id: UUID, user_input: str):
    """
    Background task to process code generation through all phases.

    Args:
        request_id: Unique request identifier
        user_input: User's natural language request
    """
    try:
        logger.info(f"开始处理代码生成请求: {request_id}")

        # Phase 1: Specify - Analyze requirements
        await _enter_phase(request_id, PhaseName.SPECIFY, "正在分析需求，定义功能边界...")

        # Simulate analysis time
        await asyncio.sleep(1)

        # Phase 2: Plan - Design technical solution
        await _enter_phase(request_id, PhaseName.PLAN, "正在设计技术方案，确定使用 Pygame 库...")

        # For MVP, assume Snake game request and prepare accordingly
        if "贪吃蛇" in user_input or "snake" in user_input.lower():
            await _generate_snake_game(request_id, user_input)
        else:
            # Generic code generation for other requests
            await _generate_generic_code(request_id, user_input)

    except Exception as e:
        logger.error(f"代码生成处理失败: {request_id} - {e}")

        # Mark request as failed
        if request_id in active_requests:
            active_requests[request_id].update_status(RequestStatus.FAILED, str(e))


async def _enter_phase(request_id: UUID, phase: PhaseName, message: str, thinking_trace: str = None):
    """Enter a new processing phase and notify listeners."""
    try:
        new_phase = ProcessPhase(
            request_id=request_id,
            phase_name=phase,
            educational_message=message,
            thinking_trace=thinking_trace
        )

        # Validate phase transition
        phases = request_phases.get(request_id, [])
        if phases:
            last_phase = phases[-1]
            if not is_valid_phase_transition(last_phase.phase_name, phase):
                logger.warning(f"无效的阶段转换: {last_phase.phase_name} -> {phase}")

        # Add phase to history
        request_phases[request_id].append(new_phase)

        logger.info(f"进入阶段 {phase.value}: {request_id}")

    except Exception as e:
        logger.error(f"进入阶段失败: {e}")


async def _generate_snake_game(request_id: UUID, user_input: str):
    """Generate Snake game code."""
    try:
        # Phase 3: Implement - Generate code
        await _enter_phase(request_id, PhaseName.IMPLEMENT, "正在编写代码...")

        # Generate Snake game code using AI service
        code_prompt = f"""
创建一个完整的贪吃蛇游戏，包含以下功能：
- 蛇的移动控制（方向键）
- 食物随机生成
- 碰撞检测（墙壁和自身）
- 分数显示
- 游戏结束处理

使用 Pygame 库实现，确保代码完整可运行。
"""

        generated_code, thinking_trace = await get_ai_service().generate_code(code_prompt, PhaseName.IMPLEMENT)

        # Add thinking trace to current phase
        if thinking_trace and request_phases[request_id]:
            request_phases[request_id][-1].thinking_trace = thinking_trace

        # Save generated files
        files = {
            "main.py": generated_code,
            "requirements.txt": "pygame==2.5.2\n",
            "README.md": """# Snake Game

一个简单的贪吃蛇游戏，使用 Pygame 实现。

## 运行方法

```bash
pip install -r requirements.txt
python main.py
```

## 控制方法

- 方向键：控制蛇的移动方向
- 目标：吃掉红色食物获得分数
- 游戏结束：撞到墙壁或自身

## 功能特点

- 实时分数显示
- 随机食物生成
- 碰撞检测
- 游戏结束重启

享受游戏！
"""
        }

        # Save project
        project = get_file_service().save_generated_files(request_id, files)

        # Mark request as completed
        if request_id in active_requests:
            active_requests[request_id].update_status(RequestStatus.COMPLETED)

        logger.info(f"Snake 游戏生成完成: {request_id}")

    except Exception as e:
        logger.error(f"Snake 游戏生成失败: {e}")
        if request_id in active_requests:
            active_requests[request_id].update_status(RequestStatus.FAILED, str(e))


async def _generate_generic_code(request_id: UUID, user_input: str):
    """Generate generic code for other requests."""
    try:
        # Phase 3: Implement - Generate code
        await _enter_phase(request_id, PhaseName.IMPLEMENT, "正在编写代码...")

        # Use AI service to generate code based on user request
        generated_code, thinking_trace = await get_ai_service().generate_code(user_input, PhaseName.IMPLEMENT)

        # Add thinking trace to current phase
        if thinking_trace and request_phases[request_id]:
            request_phases[request_id][-1].thinking_trace = thinking_trace

        # Determine file extension and create appropriate files
        if "python" in user_input.lower() or ".py" in generated_code[:200]:
            files = {
                "main.py": generated_code,
                "requirements.txt": "# Add your dependencies here\n",
                "README.md": f"""# Generated Code

Code generated from request: {user_input}

## Usage

```bash
python main.py
```

## Description

This code was generated based on your natural language request.
Please review and modify as needed for your specific use case.
"""
            }
        else:
            # Default to Python if unclear
            files = {
                "main.py": generated_code,
                "requirements.txt": "# Add your dependencies here\n",
                "README.md": f"""# Generated Code

Code generated from request: {user_input}

## Usage

```bash
python main.py
```
"""
            }

        # Save project
        project = get_file_service().save_generated_files(request_id, files)

        # Mark request as completed
        if request_id in active_requests:
            active_requests[request_id].update_status(RequestStatus.COMPLETED)

        logger.info(f"通用代码生成完成: {request_id}")

    except Exception as e:
        logger.error(f"通用代码生成失败: {e}")
        if request_id in active_requests:
            active_requests[request_id].update_status(RequestStatus.FAILED, str(e))
